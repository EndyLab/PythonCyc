<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
<head>
 <title>PythonCyc 1.0 Documentation</title>
</head>

<body>
<h1>PythonCyc 1.0 Documentation</h1>

<pre>
----------------------------------------------------------------------
Copyright (c) 2014, SRI International

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
----------------------------------------------------------------------
</pre>


<p> PythonCyc is a Python interface package to <a
 href="http://brg.ai.sri.com/ptools/">Pathway Tools</a>, version 18.5
 or above. PythonCyc has been tested with Python 2.6 and IPython on Mac
 OS X, Linux and Microsoft Windows.  Since PythonCyc is based on the programming
 language Python, you must use a Python interpreter to use
 PythonCyc. In the following we assume that you have installed Python
 (we recommend version 2.6 or above, but it most likely work with any
 2.x version).  

 For the latest news about PythonCyc, please consult the 
 <a href="http://brg.ai.sri.com/ptools/pythoncyc.html">PythonCyc web page</a>.
</p>

<h2>Installation</h2>

<p>PythonCyc should be accessible from your running Python
interpreter. To do so, install PythonCyc according to one of
the following platforms.
</p>

<h3>Mac OS X and Linux</h3>

<p>
Open a terminal window and change your directory to the location where
you unpacked the PythonCyc package. You should have the file setup.py in
that directory and the subdirectory pythoncyc. Assuming that 'shell>'
is the prompt of your current Unix shell, execute the following
command using 'sudo':
</p>

<pre>
shell> sudo python setup.py install
</pre>

<p>
This may prompt you for your login password because sudo may requires
it. This command copies several files from the pythoncyc subdirectory
to other locations on your computer where PythonCyc is installed,
byte-compiles these files and may do other operations depending on the
Python installation you have. No error messages should be reported. In case
of errors, make sure you have installed Python and that it is working. To
test your PythonCyc installation, please consult the
Section <a href="#gettingStarted">Getting Started</a> in this
document.
</p>

<h3>Microsoft Windows</h3>

On a Microsoft Windows platform, starts a command prompt window using
the start/Accessories menu, then change the directory to the location
where you unpacked the PythonCyc package. You should have the file
<tt>setup.py</tt> in that directory and the subdirectory <tt>pythoncyc</tt>. 
Then, at
the command prompt, execute the following command:

<pre> 
 python setup.py install
</pre>

This command copies several files from the pythoncyc subdirectory
to other locations on your computer where PythonCyc is installed,
byte-compiles these files and may do other operations depending on the
Python installation you have. No error messages should be reported. In case
of errors, make sure you have installed Python and that it is working. To
test your PythonCyc installation, please consult the
Section <a href="#gettingStarted">Getting Started</a> in this
document.

<h2>Getting Started</h2>
<a name="gettingStarted">

<p> Pathway Tools (version 18.5 and up) must be running on some
computer started with at least the command line option '-python' or
'-python-local-only', which starts the Python server in Pathway
Tools. If '-python' is specified, connections made to Pathway Tools
could come from a remote computer, whereas for '-python-local-only',
no remote computer can connect to the Python server. The option
'-python-local-only' is for added cybersecurity because with that
option no remote computer can access your locally running Pathway Tools
via the Python server. PythonCyc communicates to this running Pathway
Tools server via a socket on port 5008 (default setup).  It is also
recommended to start Pathway Tools with the command line option
'-lisp', so that the connection can be monitored and debugged, if need
be. In summary, we recommend to start Pathway Tools using the following options
</p>

<pre>
./pathway-tools -lisp -python
</pre>

or for added cybersecurity with the options

<pre>
./pathway-tools -lisp -python-local-only
</pre>

<p>To run PythonCyc remotely from Pathway Tools, please
read the Section <a href="#remoteaccess">Remotely Accessing Pathway
Tools</a> to setup PythonCyc to remotely access Pathway Tools.  In the
following, we assume that Pathway Tools is running on the same computer
as Python and that it has the MetaCyc database.
</p>

<p>Start a Python interpreter on the same computer as Pathway Tools.
You should get a prompt such as &gt;&gt;&gt;, then enter the following
</p>

<pre>
>>> import pythoncyc
</pre>

<p>
This command imports the PythonCyc module to access its classes,
functions and methods. If any error messages is given when this command
make sure PythonCyc has been installed according to the Installation instructions.
Then enter the command:
</p>

<pre>
>>> meta = pythoncyc.select_organism('meta')
</pre>

<p>This command sends a request to Pathway Tools to create a
<b>PGDB</b> object associated with the database MetaCyc, which is
specified using the 'meta' organism identifier (i.e., orgid). That PGDB
object is assigned to the variable <tt>meta</tt>. If you want to
have a list of all PGDBs, in their orgids, accessible from your
running Pathway Tools, use the method <tt>pythoncyc.all_orgids()</tt>.
</p>

<p>
If this command executes without any error, Pathway Tools and 
PythonCyc can communicate with each other.
</p>

Printing out the Python <tt>meta</tt> variable

<pre>
>>> print meta
&lt;PGDB meta, currently has 0 PFrames&gt;
</pre>

<p>
This means that <tt>meta</tt> is bound to a PGDB object, its orgid is meta and
it has currently no PFrames attached to it. Indeed, currently we only created
a PGDB object that has no <i>data frames</i> in it. The following sections will show
how to transfer data frames from Pathway Tools to PythonCyc.
</p>

<p>Other useful methods are available from the pythoncyc module.
Please, consult the source file __init__.py for them. Also, more
advanced technical documentation is provided for each method and
functions by consulting the PythonCyc modules config.py, PGDB.py,
PToolsFrame.py and PTools.py. As usual, the Python <tt>help</tt>
command can provide documentation about the modules, classes and
methods: for example, <tt>help(pythoncyc)</tt> prints the
documentation for the module <tt>pythoncyc</tt>; or the
command <tt>help(meta)</tt>, once variable <tt>meta</tt> is bound to a
PGDB object, prints all the methods available, and their documentation,
for a PGDB object.
</p>

<h2>Transfer of Frames From Pathway Tools using Frame Ids</h2>

<p> Using that variable <tt>meta</tt>, it is now possible to request data from the
MetaCyc database.  For example, the following statement retrieves compound
TRP (i.e., L-tryptophan). 'TRP' is the <b>frame id</b> of compound L-tryptophan), which we
can also specify in lower case letters: 
</p>

<pre>
>>> meta.trp
</pre>

<p>Evaluating <tt>meta.trp</tt>, if done for the first time, triggers
a call to Pathway Tools to transfer the <i>frame data</i> (or simply
frame) of compound TRP: the slots (also called attributes) and their
data of the Pathway Tools frame representing compound TRP are
transferred to PythonCyc to create a <b>PFrame</b> object to represent
the compound TRP. PythonCyc also prints that frame content which is
represented as a Python dictionary: the slots of the frame are
the keys of the dictionary and the value of the slots are the
values of the dictionary.
</p>

<p> Note: in Pathway Tools, the <i>slots</i> are used to access the
data of a frame (i.e., object).  In Python, an object has
<i>attributes</i>. The meaning of these two terms, that is, slots and
attributes, are very similar. A slot of a frame in Pathway Tools
becomes an attribute of a PFrame object in PythonCyc. We will use the term
slots when referring to a frame in Pathway Tools and attributes when referring
to the same slots in PythonCyc.  
</p>

<p>Printing out meta now shows that we have one PFrame attached to 
meta:
</p>

<pre>
>>> print meta
&lt;PGDB meta, currently has 1 PFrames&gt;
</pre>

<p>Indeed, this PFrame for TRP was also bound to the PGDB meta such that it
became an attribute of meta. That is, executing <tt>meta.trp</tt> again would
not retrieve the data from Pathway Tools, but directly use the PFrame
already created for it and now stored as an attribute for meta. All
created PFrames based on a PGDB object are attached to that object and
no two PFrames can have the same frame id for that PGDB object. </p>
</p>

<p>In Pathway Tools, the frame id is in upper case, that is,
'TRP'. The conversion from lower case to upper case is handled
automatically by PythonCyc.  PFrame, in PythonCyc, is the class of
objects to represent frame objects from Pathway Tools. More details
about PFrames is given below and in the Section <a
href="#pframes">PFrame Objects</a>. In particular, note that PFrames
are read only, that is, their attributes cannot be modified.  </p>

<p>From a PGDB object, a PFrame can be accessed using the frame id
either by using the attribute or indexing syntax of Python. For example, the
following would retrieve reaction with frame id RXN-9000 </p>

<pre>
>>> rxn9000 = meta['RXN-9000']
</pre>

<p>
or by using the attribute syntax
</p>

<pre>
>>> rxn9000 = meta.rxn_9000
</pre>

<p>Both forms access the same attribute. Note that the frame id
'RXN-9000' has a dash in its name but an attribute in Python cannot
have a dash. To provide access to such frame ids, using the attribute
syntax of Python, dashes are converted to underscores. Mixed cases
(i.e., upper or lower case letters) can be used for both syntax
(attributes and indexing) because an automatic conversion is done by
PythonCyc. There are cases where only the second form, the indexing
syntax, can be used. For example, for a slot name starting with a
digit, or a character that is not a letter or an underscore, the
indexing syntax with a string must be used. This is due to the syntax
of attribute names in Python which can only have letters, digits and
underscores, and cannot start with a digit. For example, the slot
name 'N+1-NAME' can only be accessed using the index syntax because
it has the character '+' which cannot be used in a Python identifier.
</p>

<p>In PythonCyc, frame ids are stored as strings prefixed and suffixed
by '|'. These vertical bars more precisely identify frame ids in
PythonCyc. Almost in all cases, you do not need to explicitly specify
the vertical bars although PythonCyc does print them to remind you
that a string represents a frame id. For example, we can see the frame
id of meta.trp by printing it: </p>

<pre>
>>> print meta.trp.frameid
|TRP|
</pre>

<p>
The syntax '|...|' is used to indicate that this string represents a frame id and can be
interpreted by Pathway Tools as a frame id. In Lisp, the programming language used
to implement Pathway Tools, the double vertical bars signifies that this is a symbol that
must be read exactly as given without any transformation (e.g., no case
conversion on letters).
</p>

<p>Technical note: all PFrames created using a PGDB object are
included in a Python dictionary bound to an attribute, of that PGDB
object, called "frames". The keys of that dictionary are the frame ids
of the PFrames converted to valid Python identifiers. The __getattr__
and __getitem__ methods of the PGDB class were written in such a way
that such an expression as 'meta.trp' searches in the dictionary for a
PFrame with frame id 'TRP'.  
</p>

<p>
Once you have access to a frame, the frame ids stored in that
frame can be used to create more PFrames. For example, the
<tt>trp</tt> object has an attribute called <tt>appears_in_right_side_of</tt>
which has a list of reaction frame ids as a value. The reaction
frame ids refer to all reactions that has TRP on its right-hand side.
The reactions can be retrieved in the following way:
<p>

<pre>
>>> rxns_trp_right = [meta[fid] for fid in meta.trp.appears_in_right_side_of]
</pre>

<p>The variable <tt>rxns_trp_right</tt> is bound to a list of PFrames 
representing the reactions. Each PFrame becomes also attributes to
<tt>meta</tt> based on the frame ids.
<p>

<p>The basic mechanism of attribute access and indexing on a PGDB
object just shown is enough to retrieve all frames from a PGDB
assuming that frame ids are known. Moreover, PFrames are implicitly
(i.e., automatically) created when doing so to store locally in Python
the data coming from Pathway Tools. The next section shows
how to retrieve large number of frames based on classes of objects,
which indirectly provides the frame ids of large number of frames.
</p>

<h2>Transfer of Classes of Frames from Pathway Tools</h2>

<p>Another implicit operations done by PythonCyc is the retrieval of
classes of objects from Pathway Tools. There are many classes of
objects, such as Reactions, Proteins, Compounds, Genes, Pathways, and
more. For example, retrieving the class of all reactions of PGDB meta,
from Pathway Tools, can be done by </p>

<pre>
>>> reactions = meta.reactions
</pre>

<p> which assign to variable <tt>reactions</tt> a PFrame representing the class
of reactions from PGDB meta. Printing out this variable gives 

<pre>
>>> reactions
&lt;PFrame class |Reactions| currently with 13081 instances (meta)&gt;
</pre>

<p>
As can be seen, <tt>reactions</tt> is a PFrame and it is a class which
has the name |Reactions| in Pathway Tools and it has 13,081 instances,
that is, 13,081 reactions, all from the PGDB meta (i.e., MetaCyc).
The number of instances may differ for you because MetaCyc is
periodically modified. Remember that the vertical bars in a name means
that it is a frame id
</p>

<p>This PFrame <tt>reactions</tt> has an attribute <tt>instances</tt>
assigned with the list of all reactions of the MetaCyc PGDB. Each such
reaction is also a PFrame, although these PFrames have currently <b>no
other data than the frame id of each reaction</b>. It is a <i>lazy
transfer</i> of the frames where only the frame ids were requested
from Pathway Tools. This approach is useful because in some cases not
all data from all reactions are needed. We can access each reaction
via the attribute <tt>instances</tt>, for example

<pre>
>>> reactions.instances[0]
</pre>

but we can also use indexing directly on the class reactions such as

<pre>
>>> reactions[0]
</pre>

You should get an output similar to:

<pre>
{'_gotframe': False, '_isclass': False, 'pgdb': meta, 'frameid': u'|3.1.22.4-RXN|'}
</pre>

but the frameid is likely different (MetaCyc is periodically
modified). As mentioned, each object in a PGDB has a unique identifier
called the frame id, which in PythonCyc is stored in the field frameid
of a PFrame. When the reactions were retrieved from Pathway Tools,
the frameid values also became an attribute of the Python PGDB object meta,
that is, we can also indexed object <tt>meta</tt> with the frame
id. For example,

<pre>
>>> meta['|3.1.22.4-RXN|']
</pre>

gives again 

<pre>
{'_gotframe': False, '_isclass': False, 'pgdb': meta, 'frameid': u'|3.1.22.4-RXN|'}
</pre>

This Python dictionary is a very short representation of the frame
with almost no data. The current attributes shown, are only created by
PythonCyc to maintain that frame in Python. If you access one
slot of that reaction frame, which is not listed in that
output, the complete frame will be retrieved from Pathway Tools. For
example,

<pre>
>>> reactions[0].left
</pre>

retrieves the data for slot <tt>left</tt> but it also <b>retrieves
all the slots and their data for that reaction</b>. Indeed, evaluating

<pre>
>>> reactions[0]
</pre>

we get all the slots and their data, that is something like

<pre>
{u'right': [u'|Resolution-of-Recombinational-Junction|'], u'schema_p':
True, '_isclass': False, u'template_file': u'enzyme.asn v.20.0',
u'creator': u'|kr|', u'left': [u'|DNA-Combined-With-Exogenous-DNA|', u'|WATER|'],
u'creation_date': 3069621160, u'reaction_direction':
u'PHYSIOL-LEFT-TO-RIGHT', 'frameid': u'|3.1.22.4-RXN|',
u'enzymatic_reaction': [u'|ENZRXN-2014|'], u'key_slots':
u'|COMMON-NAME|', u'dblinks': {u'|UNIPROT|': [u'Q55506',
u'RELATED-TO', u'green', 3381008079, None, None]},
u'physiologically_relevant_p': [True], u'synonym_slots':
[u'|ABBREV-NAME|', u'|SYNONYMS|'],
u'atom_mappings': [u'ILP-IS-EMPTY'],
'_gotframe': True, u'ec_number': [u'EC-3.1.22.4'],
u'substrates': [u'|WATER|', u'|DNA-Combined-With-Exogenous-DNA|',
u'|Resolution-of-Recombinational-Junction|'], 'pgdb': meta}
</pre>

<p>
These attributes and data are now in the Python interpreter and they
will no longer be transferred again, for that frame, from Pathway Tools unless we use
another Python method to do so. That is, this mechanism of accessing
attributes transfers <b>once</b> the attributes and data of a frame.
</p>

<p> If some piece of Python code accesses any attribute from many
frames, each frame is transferred once and kept locally. For example,
the following explicitly retrieves the left attributes for
reactions 1 to 9, from the class reactions: 

<pre>
>>> [f.left for f in reactions[1:10]]
</pre>

but it implicitly retrieves all attributes and all data for the reactions 1 to 9.
This implicit retrieval can be verified by outputing these reactions:

<pre>
>>> [f for f in reactions[1:10]]
</pre>

<p>
Naturally, we could retrieve all the frames data for all reactions by
using the complete list of reactions instead of just a slice. For
MetaCyc, that would take at least one minute, because there are
over 13,000 reactions in MetaCyc.
</p>

<h3>Explicit Transfer of Frames</h3>

<p>Another very different approach to retrieve all the data
of a list of frames is by using the Python method
<tt>get_frame_objects</tt>.
That method takes a list of frame ids as input and send a request to
Pathway Tools to transfer all the slots and their data for all the
frames identified by these frame ids. The function creates a PFrame
for each frames retrieved. But the <b>PFrames are not attached</b>
to the PGDB object.
</p>

<p>
For example, assuming that we have the variable <tt>reactions</tt>
bound to the class of reactions as in the previous section,
to retrieve all the frame data for the first 10 reactions,
the following can be used: (We limited the retrieval to the first 10 reactions to
make its execution fast)
</p>

<pre>
>>> r = meta.get_frame_objects([f.frameid for f in reactions.instances[0:10]])
</pre>

<p>
The list comprehension gathers the frame ids in one list and a call to
the <tt>get_frame_objects</tt> method is done, using the PGDB object meta, to
retrieve from Pathay Tools all the slots and their data for all the
frame ids. This approach always transfer the frames from Pathway Tools
even if we already transferred them already. This can be needed if the
frames were modified and there is a need to transfer them again.
</p>

<h2>Explicit Access to Slot Data Without PFrames</h2>

<p>Yet another very different way to access the frame data is to use
methods get_slot_value and get_slot_values. The first method retrieves a
scalar value on a slot that can only have one value whereas the second
method retrieves a list of values from a slot that can have multiple
values. In both cases, only the data from one slot is retrieved, not
the whole frame. That is, there are <b>no creation of PFrames</b> when using
these functions.
</p>

<p>For example, the following retrieve the Gibbs free
energy of reaction RXN-9000 from MetaCyc</p>

<pre>
>>> meta.get_slot_value('RXN-9000', 'GIBBS-0')
</pre>

<p>
The following retrieves the chemical formula of compound TRP
</p>

<pre>
>>> meta.get_slot_values('TRP', 'CHEMICAL-FORMULA')
</pre>

<p>The method get_slot_values is needed (instead of get_slot_value, the
singular version) because the slot 'CHEMICAL-FORMULA' keeps the
chemical formula as a list of pairs (atom-species coefficient) where
atom-species is the species of the atom (e.g., 'C' for carbon) and
coefficient is an integer. In that particular case, that is, a list of
pairs, the result will be returned as a Python dictionary where the
keys are the atom species and the values are the coefficients.
</p>

<h2>Calling Pathway Tools Functions Using a PGDB Object</h2> 

<p>Using variable meta, any of the more than 150 methods from the PGDB
module can be called, each corresponding to a specific function in
Pathway Tools. The list of these methods (or functions), and their
documentation, can be obtained by consulting the source code of module
PGDB.py or by using the standard help mechanism of Python (or
IPython).  </p>

<p>Almost all these methods do not create
PFrame objects but returns basic Python object, that is, boolean,
numbers and strings. When a Pathway Tools object (e.g., gene, pathway,
reaction) needs to be returned, the frame id (as a string)
is returned. For example, the following call
retrieves all the pathways from meta by returning a list of frame ids
(as strings):
</p>

<pre>
>>> pwys = meta.all_pathways()
</pre>

<p>To create PFrames, and the data about pathways, using frame ids, you can use the
method <tt>get_frame_objects</tt>. For example, the following will create all
the PFrames for all the frame ids in variable pwys:
</p>

<pre>
>>> pframe_pwys = meta.get_frame_objects(pwys) 
</pre>

<p>The variable <tt>pframe_pwys</tt> has been assigned a list of PFrames, one
PFrame per pathway and all created PFrame objects were bound to the
PGDB object meta.
</p>

<p>Many other Lisp functions, defined in Pathway Tools, can be called using
Python's syntax. These functions often need a frame as one of the parameter.
A frame can be specified as a frame id (a string) or as a PFrame object. For example,
</p>

<pre>
>>> meta.reactions_of_compound('TRP')
</pre>

<p>
where 'TRP' is the frame id of compound L-tryptophan. The
reactions_of_compound method (which is a function in Pathway Tools)
retrieves all reaction frame ids that
use TRP as a substrate. Note that, if the given frame id was not
existing in the PGDB, it would raise a PToolsError in PythonCyc because
Pathway Tools itself will report a 'non coercible frame'. 
</p>

<p>A PFrame can also be used instead of the frame id. For example, 
<tt>meta.trp</tt> refers to a PFrame for compound TRP and
can be used to do the same operation we just did, that is
</p>

<pre>
>>> meta.reactions_of_compound(trp)
</pre>

<p>
Some methods modify the PGDB in Pathway Tools, such as
</p>

<pre>
>>> meta.put_slot_value('RXN-9000','GIBBS-0',2.7)
</pre>

<p>
which modifies the slot 'GIBBS-0' for frame 'RXN-9000' to the value
2.7 for the PGDB associated with object meta, which in our case is MetaCyc.
</p>

<p>
Some functions have keywords arguments, which are always optional. But notice
that the default value is often the Python value <tt>None</tt>.
The value <tt>None</tt> is not translated to <tt>False</tt>, but
indicates to use the default value of the Lisp function called. These defaults
are given for each function listed below.
</p>   

<p>Again, there are many more methods that can be called to access functions
in Pathway Tools. Please, consult the file <tt>PGDB.py</tt> for the complete
list of available methods and their documentation.
</p>

<h2>More on PFrame Objects</h2>
<a name="pframes">

<p>PFrame is a Python class to represent Pathway Tools' frames in
PythonCyc. A PFrame can represent a Pathway Tools class frame (e.g.,
Reactions) as well as an instance frame (e.g., RXN-9000). PFrames are
useful to retrieve many frames and all their data from Pathway to
PythonCyc and then operate on that data locally in Python. On the
other hand, if the data needs to be modified in the PGDB of Pathway
Tools, PFrames are not useful because they are read only.
</p>

<p>As discussed in the previous sections, PFrames are automatically
created when retrieving classes, or instances using the attribute or
indexing syntax applied to a PGDB object. You could also directly create PFrames.
To do so, you need to import the class PFrame:
</p>

<pre>
>>> from pythoncyc.PToolsFrame import PFrame
</pre>

<p>
The required parameters to create a PFrame are the frame id (a string) and a PGDB
object. For example, assuming that 'meta' is bound to a PGDB object, the following
create a PFrame to represent the reaction RXN-9000,
</p>

<pre>
>>> PFrame('RXN-9000', meta)
</pre>

<p>
By default, an instance PFrame (not a class PFrame) is created and
the data of the frame is not requested from the server, that is,
a PFrame object is created containing only the frame id and the PGDB.
On the other hand, all its slots and data can be fetched from Pathway Tools by
specifying the keyword argument <tt>getFrameData=True</tt>. For example, the following
create a frame for reaction RXN-9000 and retrieve all its slots and data,
</p>

<pre>
>>> PFrame('RXN-9000', meta, getFrameData=True)
</pre>

<p>
For creating a class, the <tt>isClass</tt> keyword parameter must say so,
</p>

<pre>
>>> PFrame('Reactions', meta, isClass=True)
</pre>

<p>
When creating a class, if <tt>getFrameData=True</tt> is specified, the class slots and its
data are fetched and all the instances of the class are also created
as, mostly empty, PFrames. They are mostly empty in the sense that the
slots and data of the instances are not transferred, but only the
frame id of each frame.  
</p>

<p>
In all cases, accessing one attribute of a PFrame object will bring in all attributes data
for that PFrame, if the data for that PFrame has not been retrieved.
For example, a PFrame of a reaction which has not be populated yet, accessing the attribute left
triggers the transfer of all the slots and data, from Pathway Tools,
to the PFrame.
</p>

<p>
The attribute values of the PFrames cannot be modified, that is, attributes are read only.
On the other hand, slots of Pathway Tools' objects can be modified using methods
<tt>put_slot_value</tt> and <tt>put_slot_values</tt>. See class PGDB for these methods.
</p>

<h2>Remotely Accessing Pathway Tools</h2>
<a name="remoteaccess">

<p>It is possible to use PythonCyc to access a Pathway Tools
application running on a remote computer. First, Pathway Tools must be
started with the command line option '-python' (not
'-python-local-only'). That is,

<pre>
./pathway-tools -python
</pre>

or with also the option -lisp to get a Lisp console to monitor the Python server

<pre>
./pathway-tools -lisp -python
</pre>

<p>
Note: If you were using the option '-python-local-only' instead of '-python' 
the Python server would not accept connection from 
remote computers increasing cybersecurity.
</p>

<p>
Second, you need to
use the config module of PythonCyc to set the appropriate hostname
of that remote computer. For example, assuming that the remote computer
is at address 'ptools.mydomain.com' (this is a fictive address for
this example). The following would configure
PythonCyc to communicate with it:
</p>

<pre>
>>> import pythoncyc.config as config
>>> config.set_hostname('ptools.mydomain.com')
</pre>

<p>If for some reason the Pathway Tools Python server is not using the default port
(i.e., 5008),  but some other port such as 5000,
it can also be configured on the PythonCyc side by using set_hostport
</p>

<pre>
>>> config.set_hostport(5000)
</pre>

<p>
The preceding Python configuration must be done before any other
operation using PythonCyc.
</p>

<h2>Complete Examples</h2>

<h3>Function to Gather the Gibbs Free Energies of Substrates of Reactions</h3>

<p> This example is a function that gathers the Gibbs free energy of
the compounds involved in each reaction of a PGDB with a given
orgid. The result is a Python dictionary with keys as the frame ids of
the reactions and the values as lists of the substrates' Gibbs free
energy of each reaction.  </p>

<pre>
import pythoncyc

def gather_gibbs_cpd_reactions(orgid):
     """
     Return a dictionary of all reactions with the Gibbs free energies of formation 
     of their substrates.
     The keys are the frame ids of the reactions and the values are lists of Gibbs
     free energies of formation.
     """
     pgdb = pythoncyc.select_organism(orgid)
     rxn_frameids = pgdb.all_rxns(type='all')
     gibbs_dict = {}
     for fid in rxn_frameids:
         subs_fids = pgdb.get_slot_values(fid,'SUBSTRATES')
         gibbs_dict[fid] = [pgdb.get_slot_value(fid_cpd, 'GIBBS-0') for fid_cpd in subs_fids]
     return gibbs_dict
</pre>

<p>This function does not create any PFrame but uses the basic <tt>get_slot_value</tt>
and <tt>get_slot_values</tt> to retrieve data from Pathway Tools. The function
<tt>all_rxns</tt> retrieves the frame ids of all reactions from the PGDB,
then the substrates slot is accessed to get the compound
frame ids involved in each reaction. Finally, for each compound frame id, the slot
'GIBBS-0' is accessed to create a list of Gibbs free energies values.
</p>

<p>This function could be called in the following way assuming that
the orgid 'ecoli' is available from the Python server of Pathway Tools.
</p>

<pre>
>>> gather_gibbs_cpd_reactions('ecoli')
</pre>

<p>
This function may take more than 30 seconds to execute because it is retrieving
a large amount of data from Pathway Tools. 
</p>

<h3></h3>

<h2>Support</h2>

<p>
For comments, questions and bug reports about PythonCyc,
send an email to ptools-support@ai.sri.com
</p>

<h2>Acknowledgments</h2>

<p>Eli Bogart inspired some implementation details of PythonCyc from
its PyCyc package, Tomer Altman wrote the original Pathway Tools Lisp
API documentation at http://brg.ai.sri.com/ptools/api/ and Daniel
Weaver suggested to implement some specific functions to access the
functionality of FBA in Pathway Tools.  </p>

<hr>
</body>
</html>
